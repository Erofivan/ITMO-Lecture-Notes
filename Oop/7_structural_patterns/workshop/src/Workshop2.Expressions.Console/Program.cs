// Файл Program.cs — точка входа приложения.
// Здесь Круглов демонстрирует использование разработанной системы выражений
// и показывает, как применённые структурные паттерны работают на практике.

using Workshop2.Expressions;
using Workshop2.Expressions.Expressions;

// Создаём контекст вычисления и заполняем его переменными.
// Fluent API (метод AddVariable возвращает this) позволяет
// записать инициализацию в виде красивой цепочки вызовов.
//
// В контексте будут доступны:
// x = 2
// y = 3
ExpressionEvaluationContext context = new ExpressionEvaluationContext()
    .AddVariable("x", 2)
    .AddVariable("y", 3);

// Пример 1: Построение и вычисление выражения (x + 1) * (-y)
//
// Демонстрирует:
// 1. Fluent API для построения выражений
// 2. Паттерн Composite — комбинирование простых выражений в сложные
// 3. Паттерн Decorator — метод Negate() оборачивает выражение
// 4. Паттерн Strategy — операции сложения и умножения реализованы через разные стратегии
//
// Разбор по шагам:
// - new VariableExpression("x") — начинаем с переменной x
// - .Add(new ConstantExpression(1)) — добавляем 1, получаем (x + 1)
// - .Multiply(...) — умножаем на следующее выражение
// - new VariableExpression("y").Negate() — создаём (-y)
// Итоговое выражение: (x + 1) * (-y)
//
// При x = 2, y = 3:
// (2 + 1) * (-3) = 3 * (-3) = -9
IExpression expression = new VariableExpression("x")
    .Add(new ConstantExpression(1))
    .Multiply(new VariableExpression("y").Negate());

// Пример 2: Демонстрация частичного вычисления
//
// Комментарий Круглова показывает идею:
// Есть две взаимозависимые формулы:
// c = (x * y) + a
// a = c + 2
//
// Это циклическая зависимость — a зависит от c, c зависит от a.
// Круглов показывает, как система справляется с неизвестными переменными.

// c = (x * y) + a
// a = c + 2 

// Вычисляем c = (x * y) + a
// x и y известны (2 и 3), а вот a в контексте нет.
// Разбор вычисления:
// 1. x * y = 2 * 3 = 6 (полностью вычисляется)
// 2. 6 + a — но a неизвестна!
// 3. Система возвращает Partial результат: выражение упрощается до (6 + a)
// 4. Мы берём это упрощённое выражение через .Expression
//
// Важная демонстрация: даже если не все переменные известны,
// система всё равно упрощает выражение насколько возможно.
var c = new VariableExpression("x").Multiply(new VariableExpression("y"))
    .Add(new VariableExpression("a"))
    .Evaluate(context)
    .Expression;

// Теперь строим выражение для a = c + 2
// c здесь — это результат предыдущего вычисления, то есть упрощённое выражение (6 + a)
// Получаем: a = (6 + a) + 2
//
// Это демонстрирует, что выражения можно комбинировать динамически:
// результаты вычислений (даже частичных) — это тоже выражения,
// которые можно использовать для построения новых выражений.
var a = c.Add(new ConstantExpression(2));

// Вычисляем и выводим первое выражение: (x + 1) * (-y) = -9
// Паттерн Proxy (для умножения) в действии: 
// При первом вызове выводится "Multiplying..." и результат кешируется
Console.WriteLine(expression.Evaluate(context));

// Вычисляем и выводим то же выражение повторно
// Демонстрация работы CachingBinaryOperatorProxy:
// При втором вызове "Multiplying..." НЕ выводится, потому что результат
// умножения берётся из кеша. Это показывает, что паттерн Proxy работает.
//
// Если запустить программу, в консоли увидим:
// Multiplying...
// -9
// -9
//
// "Multiplying..." появится только один раз, хотя вычислений два!
Console.WriteLine(expression.Evaluate(context));
