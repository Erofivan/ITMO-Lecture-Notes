// Файл реализует паттерн Proxy для кеширования результатов операций.
// Это классический пример структурного паттерна Proxy, который добавляет
// дополнительную функциональность (кеширование) к существующему объекту
// без изменения его кода.

namespace Workshop2.Expressions.BinaryOperators;

// Класс CachingBinaryOperatorProxy реализует паттерн Proxy.
// Паттерн Proxy: предоставляет объект-заместитель, который контролирует доступ
// к другому объекту. В данном случае прокси добавляет кеширование результатов
// вычислений, что может значительно ускорить повторные операции с теми же аргументами.
//
// Преимущества такого подхода:
// 1. Не нужно менять код оригинального оператора
// 2. Кеширование можно включать/выключать просто обернув или не обернув оператор
// 3. Соблюдается принцип единственной ответственности: оператор занимается
//    вычислением, а прокси — кешированием
public sealed class CachingBinaryOperatorProxy : IBinaryOperator
{
    // Обёрнутый оператор, к которому прокси делегирует фактическое выполнение операции
    private readonly IBinaryOperator _binaryOperator;
    
    // Словарь для хранения закешированных результатов
    // Ключ — пара (left, right), значение — результат операции
    private readonly Dictionary<Key, double> _cache;

    // Конструктор принимает оператор, который будет обёрнут в прокси.
    // Параметры:
    //   binaryOperator — оператор, результаты которого будут кешироваться
    public CachingBinaryOperatorProxy(IBinaryOperator binaryOperator)
    {
        _binaryOperator = binaryOperator;
        _cache = [];
    }

    // Применяет операцию с кешированием результата.
    // Параметры:
    //   left — левый операнд
    //   right — правый операнд
    // Возвращает: результат операции (из кеша или вычисленный заново)
    //
    // Логика работы:
    // 1. Создаём ключ из пары аргументов
    // 2. Проверяем, есть ли результат в кеше
    // 3. Если есть — возвращаем из кеша (быстро, без вычислений)
    // 4. Если нет — вызываем реальный оператор, сохраняем результат в кеш и возвращаем его
    public double Apply(double left, double right)
    {
        var key = new Key(left, right);

        if (_cache.TryGetValue(key, out double value))
            return value;

        return _cache[key] = _binaryOperator.Apply(left, right);
    }

    // Делегирует форматирование обёрнутому оператору.
    // Прокси не меняет строковое представление — это остаётся задачей оригинального оператора.
    // Возвращает: символ операции от обёрнутого оператора
    public string Format()
        => _binaryOperator.Format();

    // Вспомогательная структура для использования в качестве ключа словаря.
    // record struct создаёт неизменяемую структуру со встроенной реализацией
    // GetHashCode и Equals, что идеально подходит для использования в Dictionary.
    // Параметры:
    //   Left — левый операнд
    //   Right — правый операнд
    private readonly record struct Key(double Left, double Right);
}
