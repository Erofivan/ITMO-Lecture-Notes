
### Фасад

Фасад - оркестрация одной или набора сложных операций в каком-либо типе. 

Фасад предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку

Представьте, что вашему коду необходимо работать с крупной библиотекой или же приложением, например Photoshop. При этом всё что вам нужно - это одна или две фукнции, например функция Color(...), которая меняет цветовую палитру изображения. Вам достаточно ограничить библиотеку этим методом.

То есть фасад — это простой интерфейс для работы со сложной подсистемой, содержащей множество классов. Фасад может иметь урезанный интерфейс, не имеющий 100% функциональности, которой можно достичь, используя сложную подсистему напрямую. Но он предоставляет именно те фичи, которые нужны клиенту, и скрывает все остальные.

Фасад полезен, если вы используете какую-то сложную библиотеку со множеством подвижных частей, но вам нужна только часть её возможностей.

Проблема: Клиенту приходится знать детали работы десятка сервисов, понимать их интерфейсы, связки, нюансы.

Решение: Клиент работает не с кучей объектов, а с одним — фасадом. Он вызывает заранее подготовленные высокоуровневые методы — и получает сложную функциональность без знаний о внутренней организации.

```csharp
// Пример интерфейса фасада
public class OrderFacade
{
    public OperationResult PlaceOrder(OrderInfo info) { ... }
    public OperationResult CancelOrder(OrderInfo info) { ... }
}
```
Клиент:
```csharp
var facade = new OrderFacade();
var result = facade.PlaceOrder(orderInfo);
```

Ещё пример. Допустим, у нас есть три внутренних сервиса:
```csharp
public class PaymentService { ... }
public class DeliveryService { ... }
public class NotificationService { ... }
```
Фасад агрегирует их:
```csharp
public class OrderFacade
{
    private readonly PaymentService _payment;
    private readonly DeliveryService _delivery;
    private readonly NotificationService _notification;

    public OrderFacade(
        PaymentService payment,
        DeliveryService delivery,
        NotificationService notification)
    {
        _payment = payment;
        _delivery = delivery;
        _notification = notification;
    }

    public OperationResult PlaceOrder(OrderInfo orderInfo)
    {
        // 1. Обработка платежа
        var paymentResult = _payment.Process(orderInfo.PaymentDetails);

        // 2. Организация доставки
        var deliveryResult = _delivery.Schedule(orderInfo.Address);

        // 3. Уведомление пользователя
        _notification.Send(orderInfo.CustomerEmail, "Ваш заказ оформлен!");

        // 4. Формирование результата
        return new OperationResult
        {
            PaymentInfo = paymentResult,
            DeliveryInfo = deliveryResult,
            Success = true
        };
    }
}
```

Интерфейсы и абстракции скрыты от клиента. Все внутренние сервисы доступны только фасад

- Фасад — агрегатор: не реализует логику сам, а координирует вызовы реальных объектов (сервисов).
- Внутренние зависимости умеют делать только свою работу (Single Responsibility).
- Фасад отвечает за orchestration (оркестрацию) — связывает, управляет порядком вызовов.

Типовые случаи применения:

- Внешние API библиотек: клиентской код работает только с фасадом.
- Интеграция сложных подсистем (как заказ: оплата + доставка + уведомление).
- "Bootstrap" запуск: инициализация системы через один метод.

Фасад позволяет легко строить request-response модель: клиент формирует запрос, фасад обрабатывает и возвращает результат.`
```csharp
public class MainWindow
{
    private readonly OrderFacade _orderFacade;

    public MainWindow()
    {
        var payment = new PaymentService();
        var delivery = new DeliveryService();
        var notify = new NotificationService();

        _orderFacade = new OrderFacade(payment, delivery, notify);
    }

    public void OnOrderButtonClicked(OrderInfo info)
    {
        var result = _orderFacade.PlaceOrder(info);
        MessageBox.Show(result.Success ? "Заказ успешно оформлен" : "Ошибка заказа");
    }
}
```

#### Недостатки

- **риск сделать god-class**
Если фасад начинает реально реализовывать всю логику сам, а не только координировать сервисы, он превращается в огромный класс с кучами методов — нарушается Single Responsibility.
- **потеря абстракций засчёт переиспользования логики внутри фасада**
Если логика внутри фасада начинает использоваться в других местах напрямую, она теряет "инкапсуляцию" и становится глобальной.
- **тяжесть рефакторинга и декомпозиции**
Сложный фасад трудно менять — большое число зависимостей, методов, связей, высокая связанность.
- **стоит приводить к request-response модели**

То есть, вместо того чтобы упаковывать всё во внутренние приватные методы, старайтесь приводить фасад к request-response модели: пусть фасад координирует выполнение одной большой операции (например, PlaceOrder), а не десятки мелких сервисных действий.

Пример применения:
```csharp
public static void Main()
{
    Console.WriteLine("=== Пример фасада ===");
    
    var payment = new PaymentService();
    var delivery = new DeliveryService();
    var notification = new NotificationService();
    
    var orderFacade = new OrderFacade(payment, delivery, notification);

    var orderInfo = new OrderInfo
    {
        PaymentDetails = new PaymentDetails { /* ... */ },
        Address = "Санкт-Петербург, Невский пр. 1",
        CustomerEmail = "ivan@mail.ru"
    };

    var result = orderFacade.PlaceOrder(orderInfo);

    if (result.Success)
        Console.WriteLine("Заказ оформлен и доставка назначена!");
    else
        Console.WriteLine("Ошибка оформления заказа.");
}
```

Применимость:
- **Когда вам нужно представить простой или урезанный интерфейс к сложной подсистеме.**
Часто подсистемы усложняются по мере развития программы. Применение большинства паттернов приводит к появлению меньших классов, но в бóльшем количестве. Такую подсистему проще повторно использовать, настраивая её каждый раз под конкретные нужды, но вместе с тем, применять подсистему без настройки становится труднее. Фасад предлагает определённый вид системы по умолчанию, устраивающий большинство клиентов.

-**Когда вы хотите разложить подсистему на отдельные слои.**
- Используйте фасады для определения точек входа на каждый уровень подсистемы. Если подсистемы зависят друг от друга, то зависимость можно упростить, разрешив подсистемам обмениваться информацией только через фасады.

Например, возьмём ту же сложную систему видеоконвертации. Вы хотите разбить её на слои работы с аудио и видео. Для каждой из этих частей можно попытаться создать фасад и заставить классы аудио и видео обработки общаться друг с другом через эти фасады, а не напрямую.

Шаги реализации:

1. Определите, можно ли создать более простой интерфейс, чем тот, который предоставляет сложная подсистема. Вы на правильном пути, если этот интерфейс избавит клиента от необходимости знать о подробностях подсистемы.

2. Создайте класс фасада, реализующий этот интерфейс. Он должен переадресовывать вызовы клиента нужным объектам подсистемы. Фасад должен будет позаботиться о том, чтобы правильно инициализировать объекты подсистемы.

3. Вы получите максимум пользы, если клиент будет работать только с фасадом. В этом случае изменения в подсистеме будут затрагивать только код фасада, а клиентский код останется рабочим.

4. Если ответственность фасада начинает размываться, подумайте о введении дополнительных фасадов.
