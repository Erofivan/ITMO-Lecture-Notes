### Введение

Паттерн проектирования — это часто встречаемое решение определённой проблемы при проектировании архитектуры программ.

Другими словами, паттерн (он же шаблон проектирования и он же design pattern) - это повторяемая архитектурная конструкция в сфере проектирования программного обеспечения, предлагающая решение проблемы проектирования в рамках некоторого часто возникающего контекста.

В отличие от готовых функций или библиотек, паттерн нельзя просто взять и скопировать в программу. Паттерн представляет собой не какой-то конкретный код, а общую концепцию или пример решения той или иной проблемы, которое нужно будет подстроить под нужды вашей программы.

Паттерны часто путают с алгоритмами, ведь оба понятия описывают типовые решения каких то известных проблем. И если алгоритм — это чёткий набор действий, то паттерн — это высокоуровневое описание решения, реализация которого может отличаться в двух разных программах.

Если привести аналогии, то алгоритм — это кулинарный рецепт с чёткими шагами, а паттерн — инженерный чертёж, на котором нарисовано решение, но не конкретные шаги его получения (то есть в рецепте нам нужно просто выполнять шаги по порядку, а вот на чертеже мы видим чертёж, но там же нет шагом как его реализовать. Дать нам чертёж какого-нибудь собора: разве мы сможем его сразу построить?)

### Из чего состоит паттерн?

Описания паттернов обычно очень формальны и чаще
всего состоят из таких пунктов:
- проблемы, которую решает паттерн;
- мотивации к решению проблемы способом, который предлагает паттерн
- структуры классов, составляющих решение;
- примера на одном из языков программирования;
- особенностей реализации в различных контекстах;
- связей с другими паттернами.

Такой формализм в описании позволяет собрать обширный
каталог паттернов, проверяя все новые паттерны на
состоятельность.

Приведём пример того, как обычно описываются паттерны на основе паттерна Посетитель (visitor) - не волнуйтесь, мы скоро его пройдём, а пока можете просто пролистать не вникая в суть (правда, не стоит сейчас тратить время на понимание этого паттерна - просто посмотрите как обычно выглядит полное или почти полное описание):
```csharp
Решаемая проблема:
Необходимо сделать какие-то несвязные операции над рядом объектов, но нужно избежать загрязнения их кода. И нет возможности или желания запрашивать тип каждого узла и осуществлять приведение указателя к правильному типу, прежде чем выполнить нужную операцию.

Задача:
Над каждым объектом некоторой структуры выполняется одна или более операций. Нужно определить новую операцию, не изменяя классы объектов.

Решение:
Для независимости посетитель имеет отдельную иерархию. Структуры имеют некий интерфейс взаимодействия.

Использование:
Если есть вероятность изменения иерархии обслуживаемого класса, либо она будет нестабильной или открытый интерфейс достаточно эффективен для доступа шаблона, то его использование будет вредоносным.

Создается базовый класс Visitor с методами visit() для каждого подкласса родительского Element. Добавьте метод accept(visitor) в иерархию Element. Для каждой операции, которая должна выполняться для объектов Element, создайте производный от Visitor класс. Реализации метода visit() должны использовать открытый интерфейс класса Element. В результате: клиенты создают объекты Visitor и передают их каждому объекту Element, вызывая accept().

Рекомендации:
Шаблон следует использовать, если: имеются различные объекты разных классов с разными интерфейсами, но над ними нужно совершать операции, зависящие от конкретных классов;
необходимо над структурой выполнить различные, усложняющие структуру операции;
часто добавляются новые операции над структурой.

Преимущества:
упрощается добавление новых операций;
объединение родственных операции в классе Visitor;
класс Visitor может запоминать в себе какое-то состояние по мере обхода контейнера.

Недостатки:
затруднено добавление новых классов, поскольку нужно обновлять иерархию посетителя и его сыновей.

Реализация:
1. Добавьте метод accept(Visitor) в иерархию «элемент».
2. Создайте базовый класс Visitor и определите методы visit() для каждого типа элемента.
3. Создайте производные классы Visitor для каждой операции, исполняемой над элементами.
4. Клиент создаёт объект Visitor и передаёт его в вызываемый метод accept().

public static class Demo
{
	private static void Main()
	{
		Point p = new Point2D(1, 2);
		IVisitor v = new Chebyshev();
		p.Accept(v);
		Console.WriteLine(p.Metric);
	}
}

internal interface IVisitor
{
	void Visit(Point2D p);
	void Visit(Point3D p);
}

internal abstract class Point
{
	public double Metric { get; set; } = -1;
	public abstract void Accept(IVisitor visitor);
}

internal class Point2D : Point
{
	public Point2D(double x, double y)
	{
		X = x;
		Y = y;
	}

	public double X { get; }
	public double Y { get; }

	public override void Accept(IVisitor visitor)
	{
		visitor.Visit(this);
	}
}

internal class Point3D : Point
{
	public Point3D(double x, double y, double z)
	{
		X = x;
		Y = y;
		Z = z;
	}

	public double X { get; }
	public double Y { get; }
	public double Z { get; }

	public override void Accept(IVisitor visitor)
	{
		visitor.Visit(this);
	}
}

internal class Euclid : IVisitor
{
	public void Visit(Point2D p)
	{
		p.Metric = Math.Sqrt(p.X*p.X + p.Y*p.Y);
	}

	public void Visit(Point3D p)
	{
		p.Metric = Math.Sqrt(p.X*p.X + p.Y*p.Y + p.Z*p.Z);
	}
}

internal class Chebyshev : IVisitor
{
	public void Visit(Point2D p)
	{
		var ax = Math.Abs(p.X);
		var ay = Math.Abs(p.Y);
		p.Metric = ax > ay ? ax : ay;
	}

	public void Visit(Point3D p)
	{
		var ax = Math.Abs(p.X);
		var ay = Math.Abs(p.Y);
		var az = Math.Abs(p.Z);
		var max = ax > ay ? ax : ay;
		if (max < az) max = az;
		p.Metric = max;
	}
}
```
### Классификация паттернов
Паттерны отличаются по уровню сложности, детализации и охвата проектируемой системы. 

Проводя аналогию со строительством, вы можете повысить безопасность перекрёстка, поставив светофор, а можете заменить перекрёсток целой автомобильной развязкой с подземными переходами.

Самые низкоуровневые и простые паттерны — идиомы. Они не очень универсальные, так как применимы только в рамках одного языка программирования. Самые универсальные — архитектурные паттерны, которые можно реализовать практически на любом языке. Они нужны для проектирования всей программы, а не отдельных её элементов.

Кроме этого, паттерны отличаются и предназначением. Мы рассмотрим три основные группы паттернов:
1. *Порождающие паттерны* беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.
2. *Структурные паттерны* показывают различные способы построения связей между объектами. 
3. *Поведенческие паттерны* заботятся об эффективной коммуникации между объектами.

### Кто придумал паттерны?

По определению, паттерны не придумывают, а скорее «открывают». Это не какие-то супер оригинальные решения, а наоборот — часто встречающиеся, типовые решения одной и той же проблемы.

Концепцию паттернов впервые описал австрийско-британский архитектор Кристофер Александер в книге «Язык шаблонов. Города. Здания. Строительство». В книге описан «язык» для проектирования окружающей среды, единицы которого — шаблоны (или паттерны, что ближе к оригинальному термину patterns) — отвечают на архитектурные вопросы: какой высоты сделать окна, сколько этажей должно быть в здании, какую площадь в микрорайоне отвести под деревья и газоны.

Идея показалась заманчивой четвёрке авторов: Эриху Гамме, Ричарду Хелму, Ральфу Джонсону, Джону Влиссидесу. 

В 1995 году они написали книгу «Design Patterns: Elements of Reusable Object-Oriented Software»1, в которую вошли 23 паттерна, решающие различные проблемы объектно-ориентированного дизайна. Название книги было слишком длинным, чтобы кто-то смог всерьёз его запомнить. Поэтому вскоре все стали назвать её «book by the gang of four», то есть «книга от банды четырёх», а затем и вовсе «GOF book». То есть когда имеется ввиду "банда четырех" имеется ввиду именно это книга (и даже скорее книга чем авторы)

### Зачем знать паттерны?

Вы можете вполне успешно работать, не зная ни одного паттерна. Более того, вы могли уже не раз реализовать какой-то из паттернов, даже не подозревая об этом. Но осознанное владение инструментом как раз и отличает профессионала от любителя. Вы можете забить гвоздь молотком, а можете и дрелью, если сильно постараетесь. Но профессионал знает, что главная фишка дрели совсем не в этом. Итак, зачем же знать паттерны?

- Проверенные решения. Вы тратите меньше времени, используя готовые решения, вместо повторного изобретения велосипеда. До некоторых решений вы смогли бы додуматься и сами, но многие могут быть для вас открытием.
- Стандартизация кода. Вы делаете меньше просчётов при проектировании, используя типовые унифицированные решения, так как все скрытые проблемы в них уже давно найдены.
- Общий программистский словарь. Вы произносите название паттерна, вместо того, чтобы час объяснять другим программистам какой крутой дизайн вы придумали и какие классы для этого нужны.

### Критика паттернов

Несмотря на свою полезность находятся и доводы против использования паттернов

Паттерны были описаны более 20-ти лет назад, поэтому только ленивый не успел бросить в них камень. Давайте рассмотрим самую популярную критику:

1. Костыли для слабого языка программирования 

Нужда в паттернах появляется тогда, когда люди выбирают для своего проекта язык программирования с недостаточным уровнем абстракции. В этом случае, паттерны — это костыль, который придаёт этому языку суперспособности.

Например, паттерн Стратегия в современных языках можно реализовать простой анонимной (лямбда) функцией.

2. Неэффективные решения

Паттерны пытаются стандартизировать подходы, которые и так уже широко используются. Эта стандартизация кажется некоторым людям догмой и они реализуют паттерны «как в книжке», не приспосабливая паттерны к реалиям проекта.

3. Неоправданное применение

Если у тебя в руках молоток, то все предметы вокруг начинают напоминать гвозди.

Похожая проблема возникает у новичков, которые только-только познакомились с паттернами. Вникнув в паттерны, человек пытается применить свои знания везде. Даже там, где можно было бы обойтись кодом попроще.

### Качества хорошей архитектуры

Прежде чем перейти к изучению конкретных паттернов, давайте поговорим о самом процессе проектирования, о том к чему надо стремиться и о том, чего надо избегать.
#### Повторное использование кода

Не секрет, что стоимость и время разработки это наиболее важные метрики при разработке любых программных продуктов. Чем меньше оба этих показателя, тем конкурентнее продукт будет на рынке и тем больше прибыли получит разработчик. Повторное использование программной архитектуры и кода — это один из самых распространённых способов снижения стоимости разработки. Логика проста: вместо того, чтобы разрабатывать что-то по втором уразу, почему бы не использовать прошлые наработки в новом проекте? 

Идея выглядит отлично на бумаге, но, к сожалению, не всякий код можно приспособить к работе в новых условиях. Слишком тесные связи между компонентами, зависимость кода от конкретных классов, а не более абстрактных интерфейсов, вшитые в код операции, которые невозможно расширить — всё это уменьшает гибкость вашей архитектуры и препятствует её повторному использованию.

На помощь приходят паттерны проектирования, которые ценой усложнения кода программы повышают гибкость её частей, упрощая дальнейшее повторное использование кода. Приведу цитату Эрика Гаммы, одного из первооткрывателей паттернов, о повторном использовании кода и роли паттернов в нём.

> Существует три уровня повторного использования кода. На самом нижнем уровне находятся классы: полезные библиотеки классов, контейнеры, а также «команды» классов вроде контейнеров/итераторов. 
> 
> Фреймворки стоят на самом верхнем уровне. В них важна только архитектура. Они определяют ключевые абстракции для решения некоторых бизнес-задач, представленных в виде классов и отношений между ними. Возьмите `JUnit`, это маленький фреймворк, даже базовый, я бы сказал. В нём есть всего несколько классов — `Test` , `TestCase` и `TestSuite` , а также связи между ними. Обычно, фреймворк имеет гораздо больший охват, чем один класс. Вы должны вклиниться в фреймворк, расширив какой-то из его классов. Всё работает по так называемому голливудскому принципу "не звоните нам, мы сами вам перезвоним". Фреймворк позволяет вам задать какое-то своё поведение, а затем сам вызывает его, когда приходит черёд что-то делать. То же происходит и в `JUnit`. Он обращается к вашему классу, когда нужно выполнить тест, но всё остальное происходит внутри фреймворка. 
> 
> Есть ещё средний уровень. Это то, где я вижу паттерны. Паттерны проектирования и меньше, и более абстрактные, чем фреймворки. Они, на самом деле, просто описание того, как парочка классов относится и взаимодействует друг с другом. Уровень повторного использования повышается, когда вы двигаетесь в направлении от конкретных классов к паттернам, а затем к фреймворкам.
>  
> Что ещё замечательно в этом среднем уровне так это то, что паттерны — это менее рискованный способ повторного использования, чем фреймворки. Разработка фреймворка — это крайне рисковая и дорогая инвестиция. В то же время, паттерны позволяют вам повторно использовать идеи и концепции в отрыве от конкретного кода

#### Расширяемость

- Вы придумали идеальную архитектуру интернет-магазина, но через месяц пришлось добавить интерфейс для заказов по телефону. 
- Вы выпустили видео игру под Windows, но затем понадобилась поддержка macOS. обращается к вашему классу, когда нужно выполнить тест, но всё остальное происходит внутри фреймворка. 
- Вы сделали интерфейсный фреймворк с квадратными кнопками, но клиенты начали просить круглые.

Всё это примеры изменений программы. Изменения часто называют главным врагом программиста.

У каждого программиста есть дюжина таких историй. Есть несколько причин, почему так происходит:

1. банальны обновления. Просто добавляем новую фичу, о поддержке который мы не думали. Из-за этого не держали в голове при написании кода, что нужно оставлять место для этой фичи
2. все мы понимаем проблему лучше в процессе её решения. Нередко к концу работы над первой версией программы, мы уже готовы полностью её переписать, так как стали лучше понимать некоторые аспекты, которые не были очевидны вначале. Сделав вторую версию, вы начинаете понимать проблему ещё лучше, вносите ещё изменения и так далее — процесс не останавливается никогда, ведь не только ваше понимание, но и сама проблема может измениться со временем. 
3. изменения могут прийти извне. У вас есть идеальный клиент, который с первого раза сформулировал то, что ему надо, а вы в точности это сделали. Прекрасно! Но вот, выходит новая версия операционной системы, в которой ваша программа перестаёт работать. Чертыхаясь, вы лезете в код, чтобы внести кое-какие изменения

>  Можно посмотреть на это с оптимистичной стороны: если кто-то просит вас что-то изменить в программе, значит она всё ещё кому-то нужна, но думаю если вы будете на постоянной основе менять код очень долго, то вас просто уволят.

Вот почему всегда надо проектировать архитектуру и писать код с учётом будущих изменений.