// Интерфейс построителя для создания статей
//
// Роль в проекте:
// Определяет контракт для пошагового создания сложных объектов статей.
// В отличие от IParagraphBuilder, здесь нет разделения на "селектор заголовка"
// и "основной построитель", так как все элементы статьи технически необязательны
// (хотя заголовок проверяется в Build()).
//
// Применяемый паттерн:
// Builder (Строитель) - для пошагового конструирования сложных объектов
//
// Структура статьи:
// Статья состоит из трех типов компонентов:
// 1. Заголовок (обязательный) - название статьи
// 2. Параграфы (необязательные, может быть несколько) - основное содержание
// 3. Автор (необязательный) - информация об авторе статьи
//
// Почему все методы возвращают IArticleBuilder:
// Это реализация fluent interface - каждый метод возвращает сам построитель,
// позволяя создавать цепочки вызовов:
//   builder.WithTitle(...).AddParagraph(...).AddParagraph(...).WithAuthor(...).Build()
//
// Такой подход делает код более читаемым и естественным для понимания,
// похожим на человеческий язык.
//
// Отличия от IParagraphBuilder:
// В IParagraphBuilder используется техника "Type State" с разделением на два интерфейса
// для обеспечения обязательного вызова WithTitle(). Здесь это не применяется, возможно:
// - Для демонстрации разных подходов к реализации Builder
// - Потому что валидация в Build() проще для статей
// - Как учебный пример различных вариаций паттерна
//
// Связь с другими компонентами:
// - Реализуется классом ArticleBuilder
// - Создает объекты IArticle
// - Работает с IParagraph для добавления параграфов
// - Используется IArticleBuilderDirector для настройки
using Workshop3.Paragraphs;

namespace Workshop3.Articles;

public interface IArticleBuilder
{
    // Устанавливает заголовок статьи
    //
    // Параметры:
    //   title - объект для отображения в качестве заголовка
    //
    // Возвращает: себя для поддержки цепочки вызовов
    //
    // Заголовок является обязательным элементом статьи, хотя это проверяется
    // только в методе Build(), а не на уровне типов как в IParagraphBuilder.
    // Если вызвать несколько раз, сохранится только последнее значение.
    IArticleBuilder WithTitle(IRenderable title);

    // Добавляет параграф в статью
    //
    // Параметры:
    //   paragraph - параграф для добавления в статью
    //
    // Возвращает: себя для поддержки цепочки вызовов
    //
    // Метод аккумулирует параграфы - каждый вызов добавляет новый параграф.
    // Параграфы отображаются в порядке добавления. Статья может не содержать
    // параграфов вообще (хотя это странный кейс).
    //
    // Type safety:
    // Параметр имеет тип IParagraph, а не IRenderable, что обеспечивает типобезопасность -
    // в статью можно добавить только валидные параграфы, а не произвольные объекты.
    IArticleBuilder AddParagraph(IParagraph paragraph);

    // Устанавливает автора статьи
    //
    // Параметры:
    //   author - объект для отображения информации об авторе
    //
    // Возвращает: себя для поддержки цепочки вызовов
    //
    // Автор является необязательным элементом. Если не вызвать этот метод,
    // статья будет без указания авторства. Обычно отображается в конце статьи.
    IArticleBuilder WithAuthor(IRenderable author);

    // Завершает процесс построения и создает финальный объект статьи
    //
    // Возвращает: готовый объект IArticle
    //
    // Терминальная операция Builder:
    // После вызова Build() построитель выполнил свою задачу. Метод проверяет
    // наличие обязательных элементов (заголовка) и создает immutable объект Article
    // с накопленными данными.
    //
    // Если обязательные элементы не установлены, выбрасывается исключение.
    // Это "fail-fast" подход - лучше упасть сразу с понятной ошибкой, чем создать
    // объект в некорректном состоянии.
    IArticle Build();
}
