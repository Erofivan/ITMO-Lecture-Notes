// Конкретная реализация статьи - составного документа
//
// Роль в проекте:
// Представляет собой immutable объект статьи, состоящей из заголовка, параграфов и автора.
// Класс выполняет две ключевые роли:
// 1. Рендеринг статьи в строковое представление (IRenderable)
// 2. Управление построителем для создания копий (IArticleBuilderDirector)
//
// Применяемые паттерны:
// 1. Composite (Компоновщик) - статья состоит из более мелких компонентов (параграфов)
// 2. Director (Директор) - может управлять Builder для создания своих копий
// 3. Immutable Object - все поля readonly, объект неизменяемый после создания
//
// Почему immutable:
// Неизменяемость (immutability) дает важные преимущества:
// - Потокобезопасность - объект можно безопасно использовать из разных потоков
// - Предсказуемость - состояние объекта не меняется со временем
// - Упрощение отладки - не нужно отслеживать, кто и когда мог изменить объект
//
// Структура статьи:
// [Заголовок]        (обязательный)
// [Параграф 1]       (необязательные, может быть несколько)
// [Параграф 2]
// ...
// [Автор]            (необязательный)
//
// Модификатор доступа public:
// Класс публичен и может использоваться внешним кодом как тип статьи,
// хотя создание должно происходить через ArticleBuilder.
//
// Sealed модификатор:
// Класс запечатан (sealed) - от него нельзя наследоваться. Это упрощает
// reasoning о коде и может дать небольшой прирост производительности.
//
// Связь с другими компонентами:
// - Реализует интерфейсы IArticle, IRenderable, IArticleBuilderDirector
// - Создается через ArticleBuilder
// - Содержит коллекцию IParagraph
// - Может содержать автора (IRenderable)
using System.Text;
using Workshop3.Paragraphs;

namespace Workshop3.Articles;

public sealed class Article : IArticle
{
    // Заголовок статьи (обязательный элемент)
    //
    // readonly гарантирует, что после создания объекта заголовок не может быть изменен.
    // Это ключевая часть обеспечения immutability.
    private readonly IRenderable _title;

    // Коллекция параграфов статьи
    //
    // Использование IEnumerable (а не List или массива в публичном API) следует принципу
    // "program to interface". Хотя внутри хранится массив (передается через ToArray()),
    // тип поля - IEnumerable, что дает гибкость и не раскрывает деталей реализации.
    private readonly IEnumerable<IParagraph> _paragraphs;

    // Автор статьи (необязательный элемент)
    //
    // Nullable тип (IRenderable?) указывает, что автор может отсутствовать.
    // readonly обеспечивает immutability.
    private readonly IRenderable? _author;

    // Конструктор для создания статьи со всеми компонентами
    //
    // Параметры:
    //   title - заголовок статьи (не может быть null)
    //   paragraphs - коллекция параграфов (может быть пустой)
    //   author - автор статьи (может быть null)
    //
    // Конструктор не выполняет валидацию - она происходит в ArticleBuilder.Build().
    // Это делает класс простым и сфокусированным на хранении данных.
    // Конструктор просто инициализирует поля переданными значениями.
    //
    // Важно: так как ArticleBuilder передает ToArray(), мы получаем snapshot параграфов,
    // и дальнейшие изменения в построителе не повлияют на эту статью.
    public Article(
        IRenderable title,
        IEnumerable<IParagraph> paragraphs,
        IRenderable? author)
    {
        _title = title;
        _paragraphs = paragraphs;
        _author = author;
    }

    // Управляет построителем, настраивая его для создания копии этой статьи
    //
    // Параметры:
    //   builder - построитель для настройки
    //
    // Возвращает: настроенный построитель, готовый для дальнейшей модификации или сборки
    //
    // Паттерн Director в действии:
    // Этот метод "обучает" построитель воссоздать структуру текущей статьи.
    // Он вызывает методы построителя в правильной последовательности с правильными данными.
    //
    // Процесс:
    // 1. Устанавливает заголовок из текущей статьи
    // 2. Добавляет все параграфы в том же порядке
    // 3. Если есть автор, устанавливает его
    // 4. Возвращает настроенный построитель
    //
    // Зачем это нужно:
    // Это элегантный способ клонирования с возможностью модификации.
    // В Program.cs это используется так:
    //   newBuilder.AddParagraph(...); // добавили новое
    //   newBuilder = article.Direct(newBuilder); // скопировали существующее
    //   IArticle newArticle = newBuilder.Build(); // получили комбинированный результат
    //
    // Альтернативы:
    // Можно было бы создать метод Clone(), но Direct() более гибкий - он позволяет
    // комбинировать содержимое нескольких статей или добавлять новые элементы.
    //
    // Важное замечание о переменной builder:
    // Переприсваивание builder на каждой итерации (builder = builder.AddParagraph(...))
    // технически избыточно в C#, так как методы возвращают this. Но это делает код
    // более явным и показывает, что мы работаем с fluent interface.
    public IArticleBuilder Direct(IArticleBuilder builder)
    {
        builder = builder.WithTitle(_title);

        foreach (IParagraph paragraph in _paragraphs)
        {
            builder = builder.AddParagraph(paragraph);
        }

        if (_author is not null)
        {
            builder = builder.WithAuthor(_author);
        }

        return builder;
    }

    // Преобразует статью в ее строковое представление
    //
    // Возвращает: многострочную строку со всем содержимым статьи
    //
    // Паттерн Composite в действии:
    // Статья сама является IRenderable и состоит из других IRenderable объектов
    // (заголовок, параграфы, автор). Метод Render() делегирует рендеринг каждому
    // вложенному объекту, собирая результаты воедино.
    //
    // Алгоритм рендеринга:
    // 1. Создаем StringBuilder для эффективной конкатенации строк
    // 2. Рендерим и добавляем заголовок с переводом строки
    // 3. Перебираем все параграфы, рендерим и добавляем каждый с новой строки
    // 4. Если автор присутствует, рендерим и добавляем его в конце
    // 5. Возвращаем собранную строку
    //
    // Использование StringBuilder:
    // StringBuilder эффективнее обычной конкатенации строк для множественных операций,
    // так как избегает создания промежуточных строковых объектов. Это важно для
    // статей с большим количеством параграфов.
    //
    // AppendLine vs Append:
    // AppendLine добавляет Environment.NewLine после каждого элемента, обеспечивая
    // правильное форматирование на разных платформах (Windows использует \r\n,
    // Unix использует \n).
    //
    // Структурное сходство с DefaultParagraph:
    // Можно заметить, что логика рендеринга Article очень похожа на DefaultParagraph.
    // Оба следуют одному паттерну: заголовок -> содержимое -> футер/автор.
    // Это показывает единообразие дизайна системы.
    public string Render()
    {
        var builder = new StringBuilder();

        builder.AppendLine(_title.Render());

        foreach (IParagraph paragraph in _paragraphs)
        {
            builder.AppendLine(paragraph.Render());
        }

        if (_author is not null)
        {
            builder.AppendLine(_author.Render());
        }

        return builder.ToString();
    }
}
