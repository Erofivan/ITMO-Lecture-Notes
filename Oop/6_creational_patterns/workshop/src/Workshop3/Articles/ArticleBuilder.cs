// Конкретная реализация построителя статей
//
// Роль в проекте:
// Реализует паттерн Builder для пошагового создания сложных объектов Article.
// Класс накапливает компоненты статьи (заголовок, параграфы, автор) и затем
// создает immutable объект Article с этими данными.
//
// Применяемый паттерн:
// Builder (Строитель) - разделяет процесс конструирования сложного объекта и его представление
//
// Зачем нужен Builder для статьи:
// Статья - это составной объект, который создается в несколько этапов:
// 1. Установка заголовка
// 2. Добавление параграфов (может быть несколько вызовов)
// 3. Установка автора (необязательно)
//
// Прямое создание через конструктор было бы неудобным:
//   new Article(title, new[] { para1, para2, para3 }, author)
//
// Builder предоставляет более естественный API:
//   new ArticleBuilder()
//     .WithTitle(title)
//     .AddParagraph(para1)
//     .AddParagraph(para2)
//     .AddParagraph(para3)
//     .WithAuthor(author)
//     .Build()
//
// Паттерн особенно полезен когда:
// - Объект имеет много необязательных параметров
// - Порядок установки параметров важен
// - Процесс создания может меняться (через Director)
//
// Модификатор доступа public:
// В отличие от построителей параграфов, ArticleBuilder публичен, так как
// статьи создаются непосредственно в клиентском коде без фабрик.
//
// Связь с другими компонентами:
// - Реализует интерфейс IArticleBuilder
// - Создает объекты Article
// - Может управляться через IArticleBuilderDirector (метод Direct)
// - Используется в Program.cs для создания статей
using Workshop3.Paragraphs;

namespace Workshop3.Articles;

public sealed class ArticleBuilder : IArticleBuilder
{
    // Заголовок статьи (будет установлен через WithTitle)
    //
    // Nullable тип указывает, что заголовок может быть не установлен в процессе построения.
    // Будет проверен на null в методе Build().
    private IRenderable? _title;

    // Список параграфов статьи
    //
    // Использует collection expression ([]) для инициализации пустого списка.
    // readonly означает, что нельзя заменить сам список, но можно изменять его содержимое.
    // Параграфы накапливаются через множественные вызовы AddParagraph().
    private readonly List<IParagraph> _paragraphs = [];

    // Автор статьи (необязательный элемент)
    //
    // Nullable тип отражает, что автор может отсутствовать.
    // Если не установлен (остается null), статья будет без указания авторства.
    private IRenderable? _author;

    // Устанавливает заголовок статьи
    //
    // Параметры:
    //   title - объект для использования в качестве заголовка
    //
    // Возвращает: себя (this) для поддержки fluent interface
    //
    // Если вызвать метод несколько раз, предыдущее значение будет перезаписано.
    // Это может быть полезно при использовании с Director - сначала Director
    // устанавливает заголовок из шаблона, затем можно его изменить.
    public IArticleBuilder WithTitle(IRenderable title)
    {
        _title = title;
        return this;
    }

    // Добавляет параграф в статью
    //
    // Параметры:
    //   paragraph - параграф для добавления
    //
    // Возвращает: себя для поддержки fluent interface
    //
    // Метод аккумулирующий - каждый вызов добавляет новый параграф в конец списка.
    // Порядок вызовов определяет порядок параграфов в финальной статье.
    // Можно вызывать многократно для создания многостраничной статьи.
    public IArticleBuilder AddParagraph(IParagraph paragraph)
    {
        _paragraphs.Add(paragraph);
        return this;
    }

    // Устанавливает автора статьи
    //
    // Параметры:
    //   author - объект для отображения информации об авторе
    //
    // Возвращает: себя для поддержки fluent interface
    //
    // Автор необязателен - если не вызвать этот метод, статья будет анонимной.
    // Обычно информация об авторе отображается в конце статьи.
    public IArticleBuilder WithAuthor(IRenderable author)
    {
        _author = author;
        return this;
    }

    // Создает финальный объект статьи со всеми накопленными данными
    //
    // Возвращает: новый immutable объект Article
    //
    // Процесс сборки:
    // 1. Проверяет наличие обязательного заголовка (title ?? throw)
    //    Если заголовок не установлен, выбрасывается ArgumentNullException
    // 2. Преобразует список параграфов в массив (ToArray())
    //    Это создает snapshot параграфов - дальнейшие изменения в построителе
    //    не повлияют на созданную статью
    // 3. Передает автора (может быть null)
    // 4. Создает и возвращает immutable объект Article
    //
    // Почему ToArray():
    // Преобразование в массив создает независимую копию параграфов.
    // Это важно для immutability - после создания статьи мы не хотим,
    // чтобы кто-то мог изменить ее параграфы через построитель.
    //
    // Fail-fast принцип:
    // Валидация происходит здесь, а не в конструкторе Article.
    // Это позволяет Article быть простым data holder, а всю логику
    // проверок держать в Builder. Разделение ответственности.
    //
    // Переиспользование Builder:
    // После вызова Build() построитель сохраняет свое состояние.
    // Теоретически можно изменить какие-то параметры и вызвать Build() снова
    // для создания похожей статьи, хотя в текущем коде это не демонстрируется.
    public IArticle Build()
    {
        return new Article(
            _title ?? throw new ArgumentNullException(nameof(_title)),
            _paragraphs.ToArray(),
            _author);
    }
}
