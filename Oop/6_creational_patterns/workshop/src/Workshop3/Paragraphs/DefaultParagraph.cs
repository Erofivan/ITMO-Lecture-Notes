// Базовая реализация параграфа без дополнительной стилизации
//
// Роль в проекте:
// Представляет собой стандартный параграф, состоящий из заголовка, содержимого
// и опционального футера. Это "чистая" реализация без применения дополнительных
// визуальных эффектов.
//
// Применяемые принципы:
// - Immutability - все поля readonly, объект нельзя изменить после создания
// - Composition over Inheritance - параграф состоит из IRenderable объектов
// - Single Responsibility - класс отвечает только за сборку и рендеринг параграфа
//
// Структура параграфа:
// [Заголовок]          (обязательный)
// [Содержимое 1]       (необязательное, может быть несколько элементов)
// [Содержимое 2]
// ...
// [Футер]              (необязательный)
//
// Модификатор доступа internal:
// Класс является внутренним (internal), потому что внешний код не должен создавать
// параграфы напрямую. Для создания параграфов предназначен паттерн Builder,
// доступный через фабрики. Это обеспечивает единообразие и контроль над процессом создания.
//
// Связь с другими компонентами:
// - Реализует интерфейс IParagraph
// - Создается через DefaultParagraphBuilder
// - Может быть обернут в StyledParagraph для добавления стилизации
// - Используется как часть Article
using System.Text;

namespace Workshop3.Paragraphs;

internal sealed class DefaultParagraph : IParagraph
{
    // Заголовок параграфа (обязательный элемент)
    //
    // Всегда отображается первым в рендеринге. Обычно это короткий текст,
    // описывающий тему или суть параграфа.
    private readonly IRenderable _title;

    // Коллекция элементов содержимого параграфа
    //
    // Может содержать любое количество элементов (включая ноль).
    // Каждый элемент рендерится на отдельной строке в порядке добавления.
    // Использование IEnumerable (а не List) следует принципу "program to interface" -
    // нам не важна конкретная реализация коллекции, важна только возможность перебора.
    private readonly IEnumerable<IRenderable> _content;

    // Футер параграфа (необязательный элемент)
    //
    // Nullable тип (IRenderable?) указывает, что футер может отсутствовать.
    // Если присутствует, отображается в самом конце параграфа.
    // Может использоваться для сносок, дополнительной информации или подписей.
    private readonly IRenderable? _footer;

    // Конструктор для создания параграфа со всеми компонентами
    //
    // Параметры:
    //   title - заголовок параграфа (обязательный)
    //   content - коллекция элементов содержимого
    //   footer - футер параграфа (может быть null)
    //
    // Конструктор просто сохраняет переданные значения в поля.
    // Вся валидация (проверка на null для обязательных полей) происходит
    // в построителе (ParagraphBuilderBase.Build()), а не здесь, что делает
    // класс более простым и сфокусированным.
    public DefaultParagraph(
        IRenderable title,
        IEnumerable<IRenderable> content,
        IRenderable? footer)
    {
        _title = title;
        _content = content;
        _footer = footer;
    }

    // Преобразует параграф в его строковое представление
    //
    // Возвращает: многострочную строку с заголовком, содержимым и футером
    //
    // Алгоритм рендеринга:
    // 1. Создаем StringBuilder для эффективной конкатенации строк
    // 2. Добавляем отрендеренный заголовок с переводом строки
    // 3. Перебираем все элементы содержимого, рендерим и добавляем каждый с новой строки
    // 4. Если футер присутствует (not null), рендерим и добавляем его
    // 5. Возвращаем собранную строку
    //
    // Использование AppendLine важно для правильного форматирования:
    // каждый элемент оказывается на отдельной строке, что делает вывод читаемым.
    //
    // Паттерн Composite в действии:
    // Параграф сам является IRenderable и состоит из других IRenderable объектов.
    // Метод Render() делегирует рендеринг каждому вложенному объекту через вызов
    // их методов Render(), собирая результаты воедино.
    public string Render()
    {
        var builder = new StringBuilder();

        builder.AppendLine(_title.Render());

        foreach (IRenderable renderable in _content)
        {
            builder.AppendLine(renderable.Render());
        }

        if (_footer is not null)
        {
            builder.AppendLine(_footer.Render());
        }

        return builder.ToString();
    }
}
