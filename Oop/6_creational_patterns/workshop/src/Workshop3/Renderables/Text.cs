// Конкретная реализация текстового объекта с поддержкой модификаторов и клонирования
//
// Роль в проекте:
// Это основной класс для работы с текстом в системе. Он хранит строковое значение и
// список модификаторов, которые применяются при рендеринге. Класс демонстрирует
// несколько паттернов проектирования в действии.
//
// Применяемые паттерны:
// 1. Prototype (Прототип) - метод Clone() для создания копий объекта
// 2. Decorator (Декоратор) - модификаторы добавляют новую функциональность без изменения базового класса
// 3. Chain of Responsibility (Цепочка обязанностей) - модификаторы применяются последовательно
//
// Особенности реализации:
// - Value является изменяемым (set), что позволяет менять текст после создания объекта
// - Модификаторы хранятся в списке и применяются в порядке добавления
// - Приватный конструктор используется для клонирования, чтобы скопировать модификаторы
//
// Связь с другими компонентами:
// - Реализует IText<Text> для поддержки клонирования с конкретным типом
// - Используется как основной носитель текста в параграфах и статьях
// - Работает в паре с TextExtensions для удобного создания стилизованного текста
using Workshop3.RenderableModifiers;

namespace Workshop3.Renderables;

public sealed class Text : IText<Text>
{
    // Список модификаторов, которые будут применены к тексту при рендеринге
    //
    // Использование readonly для коллекции означает, что нельзя заменить саму коллекцию,
    // но можно изменять ее содержимое (добавлять/удалять элементы).
    // Это обеспечивает баланс между безопасностью и гибкостью.
    private readonly List<IRenderableModifier> _modifiers;

    // Основной публичный конструктор для создания нового текстового объекта
    //
    // Параметры:
    //   value - исходная строка текста
    //
    // Создает текст без модификаторов. Модификаторы можно добавить позже через
    // метод AddModifier() или через extension-методы типа Bold(), Colored().
    public Text(string value)
    {
        Value = value;
        _modifiers = [];
    }

    // Приватный конструктор для клонирования
    //
    // Параметры:
    //   value - исходная строка текста
    //   modifiers - коллекция модификаторов для копирования
    //
    // Этот конструктор используется только внутри метода Clone() и позволяет
    // создать новый объект с уже существующим набором модификаторов.
    // Приватный доступ гарантирует, что внешний код не сможет создать объект
    // в несогласованном состоянии.
    private Text(string value, IEnumerable<IRenderableModifier> modifiers)
    {
        Value = value;
        _modifiers = modifiers.ToList();
    }

    // Текстовое содержимое
    //
    // Важная особенность: это свойство имеет public set, что делает текст изменяемым
    // после создания. Это позволяет, например, создать Text один раз и потом менять
    // его содержимое, что демонстрируется в Program.cs:
    //   renderable.Value = "1234";
    //
    // Такой подход может быть полезен для переиспользования объектов, но требует
    // осторожности, так как изменение Value влияет на все места, где используется
    // данный экземпляр Text.
    public string Value { get; set; }

    // Преобразует текст в его строковое представление с применением всех модификаторов
    //
    // Возвращает: строку с примененными стилистическими эффектами
    //
    // Использует функциональный подход через LINQ метод Aggregate для последовательного
    // применения всех модификаторов. Это элегантная реализация паттерна Chain of Responsibility:
    // - Начальное значение: Value (исходный текст)
    // - На каждой итерации: берем текущий результат и применяем к нему очередной модификатор
    // - Финальный результат: текст со всеми примененными эффектами
    //
    // Пример цепочки: исходный текст -> Bold -> Color -> результат
    public string Render()
    {
        return _modifiers.Aggregate(
            Value,
            (value, modifier) => modifier.Apply(value));
    }

    // Добавляет модификатор в конец цепочки применения
    //
    // Параметры:
    //   modifier - модификатор для добавления
    //
    // Порядок добавления модификаторов важен, так как они применяются последовательно.
    // Например, Bold().Colored() даст другой результат, чем Colored().Bold() (хотя
    // визуально в консоли это может выглядеть одинаково, порядок ANSI кодов будет разным).
    public void AddModifier(IRenderableModifier modifier)
    {
        _modifiers.Add(modifier);
    }

    // Создает копию текстового объекта с теми же значением и модификаторами
    //
    // Возвращает: новый экземпляр Text с скопированным состоянием
    //
    // Паттерн Prototype в действии. Это поверхностное (shallow) копирование:
    // - Value копируется (но string в C# immutable, так что это безопасно)
    // - Создается новый список модификаторов, но сами объекты модификаторов не копируются
    //   (так как они stateless и их можно безопасно переиспользовать)
    //
    // Клонирование необходимо для extension-методов типа Bold(), которые должны
    // возвращать новый объект, не изменяя исходный. Это обеспечивает fluent API
    // и предотвращает неожиданные побочные эффекты.
    public Text Clone()
    {
        return new Text(Value, _modifiers);
    }
}
