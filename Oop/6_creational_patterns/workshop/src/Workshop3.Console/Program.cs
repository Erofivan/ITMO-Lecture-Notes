// Демонстрационный файл для мастер-класса по порождающим паттернам проектирования
//
// Цель этого файла:
// Показать практическое применение нескольких порождающих паттернов проектирования
// в реальном сценарии создания и манипулирования статьями с параграфами.
//
// Демонстрируемые паттерны:
// 1. Builder (Строитель) - для ArticleBuilder и ParagraphBuilder
// 2. Abstract Factory (Абстрактная фабрика) - для IParagraphBuilderFactory
// 3. Decorator (Декоратор) - для StyledParagraph и модификаторов текста
// 4. Director (Директор) - для IArticleBuilderDirector (метод Direct)
// 5. Prototype (Прототип) - для клонирования текстовых объектов
//
// Структура демонстрации:
// - Создание базовой статьи с обычными параграфами
// - Создание новой статьи на основе существующей с добавлением стилизованного параграфа
// - Демонстрация изменяемости объектов Text и ее влияния
// - Вывод обеих статей для сравнения
//
// Педагогическая ценность:
// Этот код показывает, как паттерны работают вместе в реальной системе,
// а не изолированно. Студенты могут увидеть преимущества каждого паттерна
// и как они дополняют друг друга.

using System.Drawing;
using Workshop3.Articles;
using Workshop3.Paragraphs;
using Workshop3.Paragraphs.Factories;
using Workshop3.RenderableModifiers;
using Workshop3.Renderables;

// Очистка консоли для чистого вывода результатов
Console.Clear();

// Закомментированный пример создания фабрики для стилизованных параграфов
//
// Эта строка показывает альтернативный подход - если бы мы раскомментировали этот код
// и закомментировали следующую строку, все параграфы в статье были бы красными.
// Это демонстрирует мощь паттерна Abstract Factory - одна строка меняет поведение
// всей системы создания параграфов.
//
// Паттерн Abstract Factory в действии:
// Заменяя конкретную фабрику, мы меняем "семейство" создаваемых объектов.
// Здесь семейство - это обычные или стилизованные параграфы.
// var paragraphFactory = new StyledParagraphBuilderFactory(
// new ColorModifer(Color.Red));

// Создаем фабрику для обычных (нестилизованных) параграфов
//
// Паттерн Abstract Factory:
// Мы работаем через интерфейс IParagraphBuilderFactory, что позволяет легко
// заменить реализацию. Клиентский код (CreateArticle) не знает, какие именно
// параграфы создаются - обычные или стилизованные.
var paragraphFactory = new DefaultParagraphBuilderFactory();

// Создаем текст для заголовка статьи с применением жирного начертания
//
// Паттерн Prototype и Decorator одновременно:
// - Bold() создает копию текста (Prototype)
// - Добавляет BoldModifier к копии (Decorator)
// Важный момент: renderable - это изменяемый объект (Value имеет setter),
// что будет продемонстрировано ниже
Text renderable = new Text("My article").Bold();

// Создаем первую статью используя паттерн Builder
//
// Процесс создания инкапсулирован в методе CreateArticle, который:
// 1. Получает построитель статьи (ArticleBuilder)
// 2. Получает фабрику для создания параграфов
// 3. Настраивает построитель и возвращает готовую статью
//
// Паттерн Builder:
// ArticleBuilder накапливает компоненты статьи пошагово
IArticle article = CreateArticle(
    new ArticleBuilder(),
    paragraphFactory);

// Создаем новую статью на основе существующей с добавлением красного параграфа
//
// Это демонстрирует несколько паттернов одновременно:
IArticleBuilder newArticleBuilder = new ArticleBuilder();

// Шаг 1: Добавляем новый стилизованный параграф
//
// Здесь создается фабрика для красных параграфов и строится один параграф.
// Паттерн Abstract Factory + Builder + Decorator:
// - StyledParagraphBuilderFactory (Abstract Factory) создает построитель
// - Построитель (Builder) создает параграф
// - ColorModifier (Decorator) добавляет красный цвет
// First() берет первый параграф из коллекции (их два, но нам нужен только один)
newArticleBuilder.AddParagraph(BuildParagraphs(new StyledParagraphBuilderFactory(new ColorModifer(Color.Red))).First());

// Шаг 2: Копируем содержимое существующей статьи
//
// Паттерн Director:
// article.Direct() "обучает" построитель воссоздать структуру существующей статьи.
// Это элегантный способ клонирования с возможностью модификации.
// После этого вызова newArticleBuilder содержит:
// - Красный параграф (добавлен выше)
// - Все содержимое из article (добавлено через Direct)
newArticleBuilder = article.Direct(newArticleBuilder);

// Закомментированная возможность изменить заголовок
//
// Это показывает гибкость паттерна Builder - после Direct() можно продолжить
// модификацию. Если раскомментировать, новая статья получит другой заголовок.
// newArticleBuilder.WithTitle(new Text("My article (new)"));

// Демонстрация изменяемости объекта Text
//
// ВАЖНЫЙ МОМЕНТ для понимания:
// Мы изменяем Value у объекта renderable, который был использован как заголовок
// первой статьи. Однако это изменение повлияет на ОБЕ статьи, потому что:
// 1. CreateArticle использовал renderable как заголовок первой статьи
// 2. article.Direct() передал ту же ссылку в новый построитель
// 3. Обе статьи используют один и тот же объект renderable
//
// Это демонстрирует важность понимания reference types в C#.
// Изменение Value здесь изменит заголовок в обеих статьях на "1234".
//
// Альтернатива:
// Если бы мы использовали renderable.Clone(), каждая статья получила бы
// независимую копию, и изменение не повлияло бы на другие.
renderable.Value = "1234";

// Выводим новую статью (с красным параграфом + содержимое оригинальной)
//
// Паттерн Builder:
// Build() создает финальный immutable объект статьи
//
// Паттерн Composite:
// Render() рекурсивно рендерит всю иерархию объектов (статья -> параграфы -> текст)
Console.WriteLine(newArticleBuilder.Build().Render());

// Выводим оригинальную статью
//
// Обратите внимание, что заголовок будет "1234" (а не "My article"),
// потому что мы изменили renderable.Value выше.
// Это показывает побочный эффект shared mutable state.
Console.WriteLine(article.Render());

// Вспомогательный метод для создания статьи
//
// Параметры:
//   builder - построитель статьи для настройки
//   paragraphFactory - фабрика для создания параграфов
//
// Возвращает: готовую статью
//
// Этот метод демонстрирует типичный процесс использования Builder:
// 1. Установить обязательные параметры (заголовок)
// 2. Добавить содержимое (параграфы)
// 3. Установить необязательные параметры (автор)
// 4. Собрать объект (Build)
//
// Паттерн Abstract Factory:
// Метод не знает, какие конкретно параграфы создаются - он работает
// через абстракцию IParagraphBuilderFactory. Это обеспечивает гибкость.
IArticle CreateArticle(
    IArticleBuilder builder,
    IParagraphBuilderFactory paragraphFactory)
{
    // Устанавливаем заголовок статьи
    // renderable здесь - это объект Text с жирным начертанием
    builder.WithTitle(renderable);

    // Добавляем параграфы, созданные через фабрику
    //
    // BuildParagraphs создает коллекцию параграфов используя переданную фабрику.
    // Тип параграфов (обычные или стилизованные) определяется фабрикой.
    foreach (IParagraph paragraph in BuildParagraphs(paragraphFactory))
    {
        builder.AddParagraph(paragraph);
    }

    // Устанавливаем автора статьи
    // Автор - это обычный текст без стилизации
    builder.WithAuthor(new Text("ronimizy"));

    // Создаем и возвращаем готовую статью
    //
    // Паттерн Builder - терминальная операция:
    // Build() создает immutable объект Article с накопленными данными
    return builder.Build();
}

// Вспомогательный статический метод для создания набора параграфов
//
// Параметры:
//   builderFactory - фабрика для создания построителей параграфов
//
// Возвращает: коллекцию из двух параграфов
//
// static модификатор:
// Метод не использует состояние экземпляра Program, поэтому объявлен статическим.
// Это делает его чистой функцией (pure function) - результат зависит только от входных параметров.
//
// Функциональный подход:
// Использование LINQ (Enumerable.Range + Select) демонстрирует функциональный стиль
// программирования в C#. Это более декларативно, чем императивный цикл for.
static IEnumerable<IParagraph> BuildParagraphs(IParagraphBuilderFactory builderFactory)
{
    // Создаем последовательность чисел [0, 1] и трансформируем каждое в параграф
    //
    // Процесс для каждого числа i:
    // 1. builderFactory.CreateBuilder() - создаем новый построитель (Builder)
    // 2. WithTitle(...) - устанавливаем заголовок "Paragraph 1" или "Paragraph 2"
    // 3. AddContent(...) - добавляем простое содержимое "abc"
    // 4. Build() - создаем готовый параграф
    //
    // Паттерн Abstract Factory + Builder:
    // Фабрика создает построитель, построитель создает параграф.
    // Тип созданного параграфа зависит от фабрики:
    // - DefaultParagraphBuilderFactory -> DefaultParagraph
    // - StyledParagraphBuilderFactory -> StyledParagraph с модификатором
    //
    // Ленивое выполнение (Lazy Evaluation):
    // Select возвращает IEnumerable, которая выполняется лениво - параграфы
    // создаются только при итерации, а не сразу. Это эффективно для больших коллекций.
    return Enumerable
        .Range(0, 2)
        .Select(i => builderFactory
            .CreateBuilder()
            .WithTitle(new Text($"Paragraph {i + 1}"))
            .AddContent(new Text("abc"))
            .Build());
}
