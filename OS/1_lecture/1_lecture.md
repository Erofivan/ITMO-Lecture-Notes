# Лекция 1

*Операционные системы* — базовое системное программное обеспечение, управляющее работой вычислительного узла и реализующее универсальный интерфейс между аппаратным обеспечением, программным обеспечением и пользователем

Прежде чем идти дальше вспомним ключевые принципы архитектуры фон Неймана, которым нас учил дядюшка Скаков:

1. **Двоичное кодирование**
   
   Вся информация (данные и команды) представляется в виде двоичных чисел. 

2. **Адресуемость памяти** 
   
   Память организована как линейная последовательность ячеек (слов), каждая имеет уникальный адрес — целое число от 0 до N−1. Процессор может в любой момент обратиться к любой ячейке по её адресу (random access), что позволяет использовать переменные, массивы, указатели и т. п.

3. **Программное управление** 

    Работа машины полностью определяется программой, заранее записанной в память, состоящей из набора команд, которые выполняются процессором друг за другом в определённой последовательности: устройство управления последовательно выбирает команду по счётчику команд, декодирует и выполняет её. За счёт условных и безусловных переходов можно менять последовательность выполнения — так реализуются циклы, ветвления, подпрограммы.

4. **Однородность памяти**

    Программы и данные хранятся в единой памяти, в одинаковой форме. Машина не различает, что в ячейке — число, текст или команда, это просто битовый набор, интерпретация зависит от контекста выполнения. Причём они передаются по одним и тем же шинам, что порождает «узкое место фон Неймана» из‑за конкуренции за доступ к памяти.

5. **Централизованное управление и единая система шин**

    Центральный процессор управляет исполнением программ и обменивается данными с памятью и устройствами ввода‑вывода через общую систему шин.

Когда у нас есть только одна программа, то операционная система особо и не нужна: программа  будет просто использовать доступные ресурсы компьютера и как-то работать. Другое дело, когда у нас появляется ещё несколько программ. Теперь программы начинают конкурировать за ресурсы, а поэтому необходимо как-то организовать их взаимодействие. 

Мы могли бы заранее составлять список используемых программ, а в коде прописывать как те или иные программы будут взаимодействовать. Однако такая система будет убогой. Как только какое-то из приложений обновится, либо добавится ещё одно приложение, то тут же надо будет менять исходный код, чтобы обновить логику взаимодействия. Вместо этого проще каждому приложению предоставить какой-нибудь свой публичный API и передать ответственность за организацию взаимодействия новой программе. 

Именно такую роль "контроллера" и выполняет операционная система; она является "прослойкой" между software (программное обеспечение), hardware (аппаратное обеспечение) и user (пользователь). 

![Схема фон Неймана](src/os_interaction.pdf)

Кто-то может спросить: но ведь мы итак взаимодействуем напрямую с программным обеспечением, когда, например, нажимаем на кнопки в приложении (например что-то гуглим). Но на самом деле нет. Это нам так кажется. Например, когда какое-то особенно багованное приложение зависает и мы пытаемся нажать на крестик, но оно всё равно не закрывается. Наш запрос в любом случае сначала поступает в операционную систему, и лишь потом к приложению. Если бы это было не так, то мы бы могли напрямую закрывать такие приложения, а мы так не можем.